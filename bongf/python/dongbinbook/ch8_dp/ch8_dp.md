## 중복되는 연산을 줄이자
-   https://www.youtube.com/watch?v=5Lu34WIx2Us
-   피보나치 수열 같은 계속해서 연산을 해서 다음 값을 구하는 등의 로직은 원하는 답을 구하기 위해서 무지막지한 연산이 일어난다. 
-   이 때 도움이 되는 것이 다이나믹 프로그래밍 
-   다이나믹 프로그래밍이란 큰문제를 작게 나누고 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법 
-   다이나믹 프로그래밍 사용할 수 있는 조건 
    -   1. 큰 문제를 작은 문제로 나눌 수 있다. 
    -   2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제이서도 동일한다. 
-   피보나치 함수 소스코드 
```python
def fibo(x) :
    if x==1 or x==2 :
        return 1
    return fibo(x-1) + fibo(x-2)
```
-   dp 해결방식은 상향식과 하향식이 있다. 
-   하향식(탑다운) : 메모이제이션(Memoization) 기법을 사용해서 해결하기 
    -   재귀함수를 사용한다. 
    -   메모제이션이란?
        -   한 번 구한 결과를 메모리 공간에 저장해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법 
        -   값을 저장하는 방법이므로 캐싱 Caching 이라고도 한다. 
    -   메모제이션을 이용한 해결
        -   다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오기 
```python 
d = [0] * 100

def fibo(x) :
    if x==1 or x==2 :
        return 1
    if d[x] != 0 :
        return d[x]
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]
```
-   하향식 : 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하연 탑다운 Top-Down 방식이라고도 한다. (하향식)
    -   반복문을 사용한다 
    -   단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 Bottom-up 방식이라고 말한다. (상향식) 
    -   다이나믹 프고르매의 전형적 형태는 보텀업 
    -   보텀업 방식에서 사용되는 결과 저장용 리스트는 'DP 테이블'이라고 부른다.
    -  엄밀히 말하면 다니아믹 프로그래밍에 국한된 개념은 아닙니다. 
        -   메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미 
        -   한번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다. 
        -   다만, 다이나믹 프로그래밍을 해결할 때 하향식 방법으로 접근 할 때 이미 계산된 결과를 기록하는 방식으로 메모이제이션을 사용할 수 있는 것  
-   피보나치 수열을 보텀업 방식으로 푼 경우 (동일한 원리는 적용하되 단순히 반복문을 이용하여 문제를 푼 것으로 이해)
```python 
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1) :
    d[i] = d[i-1] + d[i-2]
```
-   코딩테스트에서의 다이나믹 프로그래밍 문제는 대체로 간단한 형태로 출제, 이 책에서 다루는 문제 정도만 바르게 습득해도 된다.
-   다이나믹 프로그래밍 VS  분할정보
    -   둘 다 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결한다는 공통점 있으나 
    -   이 둘의 중요한 차이는 부분문제의 중복
    -   다이나믹은 부분 문제의 중복이 있고 각 부분 문제들이 서로 영향을 미친다 
    -   분할정복문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다
-   문제접근
    -   1. 주어진 문제가 다이나믹 프로그래밍 유형인지 파악하자 
        -   먼저 그리디, 구현, 완적탐색 등의 아이디어로 문제를 해결할 수 있는지 검토 
        -   다른 알고리즘 풀이 방법이 떠오르지 않으다면 DP를 고려해보자 
            -   작은 문제 조합해서 큰 문제 해결
            -   그 부분문제가 중복되는 특성
        -   일단 재귀함수로 비효율적인 완전 탐색 프로그램 작성한 뒤에(탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면 메모제이션 기법 추가하여 작은 문제의 결과가 리스트 등에 저장되게 하여 코드를 개선하는 방법 
        -   반복적으로 접해보면 알 것 
-   더 참고 
    -   https://zzonglove.tistory.com/13
    -   대표문제 : 배낭 알고리즘 knapsack 
